<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# ordered

```go
import "github.com/brackendawson/ordered"
```

ordered contains ordered data structures

## Index

- [type Map](<#type-map>)
  - [func (m *Map[K, V]) Delete(key K)](<#func-mapk-v-delete>)
  - [func (m *Map[K, V]) Index(n int) (key K, value V, loaded bool)](<#func-mapk-v-index>)
  - [func (m *Map[K, V]) Len() int](<#func-mapk-v-len>)
  - [func (m *Map[K, V]) Load(key K) (value V, ok bool)](<#func-mapk-v-load>)
  - [func (m *Map[K, V]) LoadAndDelete(key K) (value V, loaded bool)](<#func-mapk-v-loadanddelete>)
  - [func (m *Map[K, V]) LoadAndDeleteFirst() (key K, value V, loaded bool)](<#func-mapk-v-loadanddeletefirst>)
  - [func (m *Map[K, V]) LoadAndDeleteLast() (key K, value V, loaded bool)](<#func-mapk-v-loadanddeletelast>)
  - [func (m *Map[K, V]) LoadOrStore(key K, value V) (actual V, loaded bool)](<#func-mapk-v-loadorstore>)
  - [func (m *Map[K, V]) Range(f func(index int, key K, value V) bool)](<#func-mapk-v-range>)
  - [func (m *Map[K, V]) Store(key K, value V)](<#func-mapk-v-store>)
  - [func (m *Map[K, V]) StoreFirst(key K, value V)](<#func-mapk-v-storefirst>)
  - [func (m *Map[K, V]) Swap(i, j int)](<#func-mapk-v-swap>)
- [type Ordered](<#type-ordered>)
- [type SortMap](<#type-sortmap>)
  - [func (m *SortMap[K, V]) Less(i, j int) bool](<#func-sortmapk-v-less>)


## type Map

Map is an ordered map data structure that is safe for concurrent use by multiple goroutines without additional locking or coordination\.

The zero Map is empty and ready for use\. A Map must not be copied after first use\.

```go
type Map[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

### func \(\*Map\[K\, V\]\) Delete

```go
func (m *Map[K, V]) Delete(key K)
```

Delete deletes the vlaue for a key

### func \(\*Map\[K\, V\]\) Index

```go
func (m *Map[K, V]) Index(n int) (key K, value V, loaded bool)
```

Index loads the key and value of the key at index n\. The loaded result reports whether the index was in range\. Negative value of n index from the end of the Map\.

### func \(\*Map\[K\, V\]\) Len

```go
func (m *Map[K, V]) Len() int
```

Len returns the number of keys in Map

### func \(\*Map\[K\, V\]\) Load

```go
func (m *Map[K, V]) Load(key K) (value V, ok bool)
```

Load returns the value stored in the map for a key\, or nil if no value is present\. The ok result indicates whether value was found in the map\.

### func \(\*Map\[K\, V\]\) LoadAndDelete

```go
func (m *Map[K, V]) LoadAndDelete(key K) (value V, loaded bool)
```

LoadAndDelete deletes the value for a key\, returning the previous value if any\. The loaded result reports whether the key was present\.

### func \(\*Map\[K\, V\]\) LoadAndDeleteFirst

```go
func (m *Map[K, V]) LoadAndDeleteFirst() (key K, value V, loaded bool)
```

LoadAndDeleteFirst delered the last key\, returning the kay and its previous value if any\. The loaded result reports whether the key was present\.

### func \(\*Map\[K\, V\]\) LoadAndDeleteLast

```go
func (m *Map[K, V]) LoadAndDeleteLast() (key K, value V, loaded bool)
```

LoadAndDeleteLast delered the last key\, returning the kay and its previous value if any\. The loaded result reports whether the key was present\.

### func \(\*Map\[K\, V\]\) LoadOrStore

```go
func (m *Map[K, V]) LoadOrStore(key K, value V) (actual V, loaded bool)
```

LoadOrStore returns the existing value for the key if present\. Otherwise\, it stores and returns the given value\, adding it to the end\. The loaded result is true if the value was loaded\, false if stored\.

### func \(\*Map\[K\, V\]\) Range

```go
func (m *Map[K, V]) Range(f func(index int, key K, value V) bool)
```

Range calls f sequentially for each key and value present in the map\. If f returns false\, range stops the iteration\.

Range does not necessarily correspond to any consistent snapshot of the Map's contents: nevery index will be visited in order\, but if the value for any key stored or deleted concurrently \(including by f\)\, Range may reflect any mapping for that key from any point during the Range call\. Range does not block other methods on the receiver; even f itself may call any method on m\.

### func \(\*Map\[K\, V\]\) Store

```go
func (m *Map[K, V]) Store(key K, value V)
```

Store sets the value for a key adding it to the end if it was not in the map\.

### func \(\*Map\[K\, V\]\) StoreFirst

```go
func (m *Map[K, V]) StoreFirst(key K, value V)
```

StoreFirst sets the value for a key adding it to the beginning if it was not in the map\.

### func \(\*Map\[K\, V\]\) Swap

```go
func (m *Map[K, V]) Swap(i, j int)
```

Swap swaps the position of the keys at indicies i and j\.

## type Ordered

Ordered represents all orderable types\.

Deprecated: This will be removed when the constraints package is added to the standard library\.

```go
type Ordered interface {
    // contains filtered or unexported methods
}
```

## type SortMap

SortMap is a Map which fully impliments sort\.Interface\. Sort is not sortable if the key type is float and NaN is used as a key\.

```go
type SortMap[K Ordered, V any] struct {
    // contains filtered or unexported fields
}
```

### func \(\*SortMap\[K\, V\]\) Less

```go
func (m *SortMap[K, V]) Less(i, j int) bool
```

Less returns true if the key at index i is less than the key at index j\.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
